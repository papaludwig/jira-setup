---
schemaVersion: '0.3'
description: Run Ansible on a stack-managed EC2 instance and return stdout/stderr

parameters:
  StackName:
    type: String
  AnsibleS3Bucket:
    type: String
  AnsibleS3Key:
    type: String
  AnsibleUser:
    type: String
    default: ansible
  JiraDownloadUrl:
    type: String
  JiraDbPassword:
    type: String
  JiraTlsCertB64:
    type: String
  JiraTlsKeyB64:
    type: String

mainSteps:
  - name: DescribeStack
    action: aws:executeAwsApi
    inputs:
      Service: cloudformation
      Api: DescribeStacks
      StackName: '{{ StackName }}'
    outputs:
      - Name: Stacks                 # <-- expose the full list
        Selector: $.Stacks
        Type: MapList                # <-- valid type; 'Map' is not allowed

  - name: ExtractInstance
    action: aws:executeScript
    inputs:
      Runtime: python3.11
      Handler: get_instance
      Script: |-
        def get_instance(event, _):
            stacks = event.get('stacks', [])
            if isinstance(stacks, list) and stacks:
                stack0 = stacks[0]
                for o in stack0.get('Outputs', []):
                    if o.get('OutputKey') == 'InstanceId':
                        return {'InstanceId': str(o.get('OutputValue'))}
                raise ValueError('No InstanceId output found in the stack.')
            raise ValueError('No stacks returned by DescribeStacks.')
      InputPayload:
        stacks: '{{ DescribeStack.Stacks }}'   # <-- pass the list, not [0]
    outputs:
      - Name: InstanceId
        Selector: $.Payload.InstanceId
        Type: String

  - name: BuildExtraVars
    action: aws:executeScript
    inputs:
      Runtime: python3.11
      Handler: build_vars
      Script: |-
        import json
        def build_vars(event, _):
            return {
              'ExtraVars': json.dumps({
                'jira_download_url': event['jira_download_url'],
                'jira_db_password': event['jira_db_password'],
                'jira_tls_cert_b64': event['jira_tls_cert_b64'],
                'jira_tls_key_b64': event['jira_tls_key_b64'],
                'ansible_user': event['ansible_user'],
              })
            }
      InputPayload:
        jira_download_url: '{{ JiraDownloadUrl }}'
        jira_db_password: '{{ JiraDbPassword }}'
        jira_tls_cert_b64: '{{ JiraTlsCertB64 }}'
        jira_tls_key_b64: '{{ JiraTlsKeyB64 }}'
        ansible_user: '{{ AnsibleUser }}'
    outputs:
      - Name: ExtraVars
        Selector: $.Payload.ExtraVars
        Type: String

  - name: InstallCollections
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: SendCommand
      DocumentName: AWS-RunShellScript
      InstanceIds:
        - '{{ ExtractInstance.InstanceId }}'
      Parameters:
        commands:
          - set -euo pipefail
          # Ensure Python3/pip present
          - |
            if command -v dnf >/dev/null 2>&1; then
              dnf -y install python3 python3-pip unzip || true
            elif command -v yum >/dev/null 2>&1; then
              yum -y install python3 python3-pip unzip || true
            elif command -v apt-get >/dev/null 2>&1; then
              apt-get update -y
              apt-get install -y python3 python3-pip unzip || true
            fi
          # Choose ansible-core band from Python version (YAML-safe; no here-docs)
          - |
            if python3 -c 'import sys; sys.exit(0 if sys.version_info >= (3,11) else 1)'; then
              AC_RANGE='ansible-core>=2.18,<2.19'
            elif python3 -c 'import sys; sys.exit(0 if sys.version_info >= (3,10) else 1)'; then
              AC_RANGE='ansible-core>=2.17,<2.18'
            else
              echo "ERROR: Need Python >=3.10 for modern ansible-core" >&2
              exit 1
            fi
            echo "Installing $AC_RANGE"
          - |
            PIP="python3 -m pip"
            set +e
            $PIP install --upgrade pip || $PIP install --upgrade pip --break-system-packages
            set -e
            $PIP install "$AC_RANGE" || $PIP install "$AC_RANGE" --break-system-packages
            # PostgreSQL driver for community.postgresql modules
            $PIP install 'psycopg2-binary>=2.9' || $PIP install 'psycopg[binary]>=3.1' --break-system-packages || true
          # Install only the needed collections (pinned majors)
          - >
            ansible-galaxy collection install
            'community.general:>=11.0.0,<12.0.0'
            'community.postgresql:>=4.0.0,<5.0.0'
            --force
          - ansible --version
        executionTimeout: ["2400"]

  - name: RunAnsible
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: SendCommand
      DocumentName: AWS-ApplyAnsiblePlaybooks
      InstanceIds:
        - '{{ ExtractInstance.InstanceId }}'
  
      # âœ… Run Command's own timeout (API-level)
      TimeoutSeconds: 3600
  
      # (Optional but recommended: persistent logs)
      # CloudWatchOutputConfig:
      #   CloudWatchOutputEnabled: true
      #   CloudWatchLogGroupName: '/ssm/ansible'
      # OutputS3BucketName: your-log-bucket
      # OutputS3KeyPrefix: 'ssm-ansible/{{ automation:EXECUTION_ID }}'
  
      Parameters:
        SourceType: ['S3']
        # Use the path-style form exactly as in AWS docs:
        SourceInfo: ['{"path":"https://s3.amazonaws.com/{{ AnsibleS3Bucket }}/{{ AnsibleS3Key }}"}']
        InstallDependencies: ['False']
        PlaybookFile: ['playbooks/site.yml']
        ExtraVariables: ['{{ BuildExtraVars.ExtraVars }}']
        Check: ['False']
        Verbose: ['-vv']
    outputs:
      - Name: CommandId
        Selector: $.Command.CommandId
        Type: String
    - name: WaitForCommand
      action: aws:waitForAwsResourceProperty
      inputs:
        Service: ssm
        Api: ListCommandInvocations
        CommandId: '{{ RunAnsible.CommandId }}'
        InstanceId: '{{ ExtractInstance.InstanceId }}'
        Details: true
        PropertySelector: '$.CommandInvocations[0].Status'
        DesiredValues: ['Success', 'Failed', 'Cancelled', 'TimedOut']
  
  - name: DiscoverPlugins
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: ListCommandInvocations
      CommandId: '{{ RunAnsible.CommandId }}'
      InstanceId: '{{ ExtractInstance.InstanceId }}'
      Details: true
    outputs:
      - Name: Plugins
        Selector: $.CommandInvocations[0].CommandPlugins
        Type: MapList

  - name: PickAnsiblePlugin
    action: aws:executeScript
    inputs:
      Runtime: python3.11
      Handler: pick
      Script: |-
        def pick(event, _):
            plugins = event.get('plugins', [])
            candidates = [p for p in plugins if p.get('Name') == 'aws:runShellScript']
            if candidates:
                return {'PluginName': candidates[-1].get('Name')}
            if plugins:
                return {'PluginName': plugins[-1].get('Name')}
            raise ValueError('No plugins found for command.')
      InputPayload:
        plugins: '{{ DiscoverPlugins.Plugins }}'
    outputs:
      - Name: PluginName
        Selector: $.Payload.PluginName
        Type: String

  - name: GetAnsibleOutput
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: GetCommandInvocation
      CommandId: '{{ RunAnsible.CommandId }}'
      InstanceId: '{{ ExtractInstance.InstanceId }}'
      PluginName: '{{ PickAnsiblePlugin.PluginName }}'
    outputs:
      - Name: StdOut
        Selector: $.StandardOutputContent
        Type: String
      - Name: StdErr
        Selector: $.StandardErrorContent
        Type: String
      - Name: InvocationStatus
        Selector: $.Status
        Type: String

outputs:
  - 'ExtractInstance.InstanceId'
  - 'RunAnsible.CommandId'
  - 'GetAnsibleOutput.StdOut'
  - 'GetAnsibleOutput.StdErr'
  - 'GetAnsibleOutput.InvocationStatus'
