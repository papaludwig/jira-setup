---
schemaVersion: '0.3'
description: Run Ansible on a stack-managed EC2 instance and return stdout/stderr

parameters:
  StackName:
    type: String
  AnsibleS3Bucket:
    type: String
  AnsibleS3Key:
    type: String
  AnsibleUser:
    type: String
    default: ansible
  JiraDownloadUrl:
    type: String
  JiraDbPassword:
    type: String
  JiraTlsCertB64:
    type: String
  JiraTlsKeyB64:
    type: String

mainSteps:
  - name: DescribeStack
    action: aws:executeAwsApi
    inputs:
      Service: cloudformation
      Api: DescribeStacks
      StackName: '{{ StackName }}'
    outputs:
      - Name: Stack
        Selector: $.Stacks[0]
        Type: Map

  - name: ExtractInstance
    action: aws:executeScript
    inputs:
      Runtime: python3.11
      Handler: get_instance
      Script: |-
        def get_instance(event, _):
            for o in event.get('stack', {}).get('Outputs', []):
                if o.get('OutputKey') == 'InstanceId':
                    return {'InstanceId': str(o.get('OutputValue'))}
            raise ValueError('No InstanceId output found in the stack.')
      InputPayload:
        stack: '{{ DescribeStack.Stack }}'
    outputs:
      - Name: InstanceId
        Selector: $.Payload.InstanceId
        Type: String

  - name: BuildExtraVars
    action: aws:executeScript
    inputs:
      Runtime: python3.11
      Handler: build_vars
      Script: |-
        import json
        def build_vars(event, _):
            return {
              'ExtraVars': json.dumps({
                'jira_download_url': event['jira_download_url'],
                'jira_db_password': event['jira_db_password'],
                'jira_tls_cert_b64': event['jira_tls_cert_b64'],
                'jira_tls_key_b64': event['jira_tls_key_b64'],
                'ansible_user': event['ansible_user'],
              })
            }
      InputPayload:
        jira_download_url: '{{ JiraDownloadUrl }}'
        jira_db_password: '{{ JiraDbPassword }}'
        jira_tls_cert_b64: '{{ JiraTlsCertB64 }}'
        jira_tls_key_b64: '{{ JiraTlsKeyB64 }}'
        ansible_user: '{{ AnsibleUser }}'
    outputs:
      - Name: ExtraVars
        Selector: $.Payload.ExtraVars
        Type: String

  - name: InstallCollections
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: SendCommand
      DocumentName: AWS-RunShellScript
      InstanceIds:
        - '{{ ExtractInstance.InstanceId }}'
      Parameters:
        commands:
          - set -euo pipefail
          # 1) Ensure ansible is present (package mgrs or pip as a fallback)
          - |
            if ! command -v ansible-galaxy >/dev/null 2>&1; then
              if command -v dnf >/dev/null 2>&1; then
                dnf -y install ansible-core python3-pip
              elif command -v yum >/dev/null 2>&1; then
                if command -v amazon-linux-extras >/dev/null 2>&1; then amazon-linux-extras enable ansible2 || true; fi
                yum -y install ansible python3-pip || yum -y install ansible-core python3-pip
              elif command -v apt-get >/dev/null 2>&1; then
                apt-get update
                apt-get -y install ansible python3-pip
              else
                python3 -m pip install --upgrade pip
                python3 -m pip install 'ansible>=2.15,<2.18'
              fi
            fi
          # 2) Ensure boto3 for amazon.aws (only needed if you actually use it)
          - |
            python3 - <<'PY'
            import importlib, sys, subprocess
            try:
                importlib.import_module('boto3')
            except Exception:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--quiet', 'boto3', 'botocore'])
            PY
          # 3) Install the collections into the default path (~/.ansible/collections)
          - ansible-galaxy collection install amazon.aws community.postgresql community.general --force
        executionTimeout: ["1800"]

  - name: InstallCollections
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: SendCommand
      DocumentName: AWS-RunShellScript
      InstanceIds:
        - '{{ ExtractInstance.InstanceId }}'
      Parameters:
        commands:
          - set -euo pipefail
          # --- Ensure Python3 + pip + unzip exist (varies by distro) ---
          - |
            if command -v dnf >/dev/null 2>&1; then
              dnf -y install python3 python3-pip unzip || true
              # Try to add Python 3.11 if only older Python is present
              if ! python3 - <<'PY' 2>/dev/null; then pass
  PY
              then dnf -y install python3.11 python3.11-pip || true; fi
            elif command -v yum >/dev/null 2>&1; then
              yum -y install python3 python3-pip unzip || true
            elif command -v apt-get >/dev/null 2>&1; then
              apt-get update -y
              apt-get install -y python3 python3-pip unzip || true
            fi
  
          # --- Pick ansible-core band based on available Python ---
          - |
            PYMIN=$(python3 - <<'PY'
            import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")
  PY
            ) || PYMIN="0.0"
            echo "Detected python3: ${PYMIN}"
  
            # Default to 2.17 if python3 is 3.10; prefer 2.18 if python3 >= 3.11
            if python3 - <<'PY'
  import sys
  exit(0 if sys.version_info >= (3,11) else 1)
  PY
            then
              export AC_RANGE='ansible-core>=2.18,<2.19'
            elif python3 - <<'PY'
  import sys
  exit(0 if sys.version_info >= (3,10) else 1)
  PY
            then
              export AC_RANGE='ansible-core>=2.17,<2.18'
            else
              echo "ERROR: Need Python >=3.10 for modern ansible-core. Please use an AMI with Python 3.10+ (e.g., Ubuntu 22.04, AL2023, RHEL9) or add install steps for Python 3.11." >&2
              exit 1
            fi
            echo "Installing $AC_RANGE"
  
          # --- Install/upgrade pip, then install ansible-core and deps (boto3/psycopg) ---
          - |
            PIP="python3 -m pip"
            set +e
            $PIP install --upgrade pip || $PIP install --upgrade pip --break-system-packages
            set -e
            $PIP install "$AC_RANGE" || $PIP install "$AC_RANGE" --break-system-packages
            # amazon.aws >= 9 expects boto3/botocore >= 1.34
            $PIP install 'boto3>=1.34' 'botocore>=1.34' || $PIP install 'boto3>=1.34' 'botocore>=1.34' --break-system-packages
            # PostgreSQL driver for community.postgresql modules
            $PIP install 'psycopg2-binary>=2.9' || $PIP install 'psycopg[binary]>=3.1' --break-system-packages || true
  
          # --- Install collections with pinned majors (range specifiers) ---
          - >
            ansible-galaxy collection install
            'amazon.aws:>=9.0.0,<10.0.0'
            'community.general:>=11.0.0,<12.0.0'
            'community.postgresql:>=4.0.0,<5.0.0'
            --force
  
          - ansible --version
        executionTimeout: ["2400"]

  - name: RunAnsible
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: SendCommand
      DocumentName: AWS-ApplyAnsiblePlaybooks
      InstanceIds:
        - '{{ ExtractInstance.InstanceId }}'
      Parameters:
        SourceType: ['S3']
        SourceInfo: ['{"path":"https://{{ AnsibleS3Bucket }}.s3.amazonaws.com/{{ AnsibleS3Key }}"}']
        InstallDependencies: ['False']        # <â€” flipped from True
        PlaybookFile: ['playbooks/site.yml']
        ExtraVariables: ['{{ BuildExtraVars.ExtraVars }}']
        Check: ['False']
        Verbose: ['-vv']
        TimeoutSeconds: ['3600']
    outputs:
      - Name: CommandId
        Selector: $.Command.CommandId
        Type: String

  # Wait for a terminal status so we can always capture logs (success or fail).
  - name: WaitForCommand
    action: aws:waitForAwsResourceProperty
    inputs:
      Service: ssm
      Api: ListCommandInvocations
      CommandId: '{{ RunAnsible.CommandId }}'
      InstanceId: '{{ ExtractInstance.InstanceId }}'
      Details: true
      PropertySelector: '$.CommandInvocations[0].Status'
      DesiredValues: ['Success', 'Failed', 'Cancelled', 'TimedOut']

  # Get the list of plugins used by this SendCommand (download, shell, etc.)
  - name: DiscoverPlugins
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: ListCommandInvocations
      CommandId: '{{ RunAnsible.CommandId }}'
      InstanceId: '{{ ExtractInstance.InstanceId }}'
      Details: true
    outputs:
      - Name: Plugins
        Selector: $.CommandInvocations[0].CommandPlugins
        Type: MapList

  # Pick the plugin that actually ran Ansible (aws:runShellScript).
  - name: PickAnsiblePlugin
    action: aws:executeScript
    inputs:
      Runtime: python3.11
      Handler: pick
      Script: |-
        def pick(event, _):
            # Prefer the last aws:runShellScript plugin (that's the Ansible run).
            plugins = event.get('plugins', [])
            candidates = [p for p in plugins if p.get('Name') == 'aws:runShellScript']
            if candidates:
                return {'PluginName': candidates[-1].get('Name')}
            # Fallback to the last plugin if not found
            if plugins:
                return {'PluginName': plugins[-1].get('Name')}
            raise ValueError('No plugins found for command.')
      InputPayload:
        plugins: '{{ DiscoverPlugins.Plugins }}'
    outputs:
      - Name: PluginName
        Selector: $.Payload.PluginName
        Type: String

  # Fetch stdout/stderr for the selected plugin.
  - name: GetAnsibleOutput
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: GetCommandInvocation
      CommandId: '{{ RunAnsible.CommandId }}'
      InstanceId: '{{ ExtractInstance.InstanceId }}'
      PluginName: '{{ PickAnsiblePlugin.PluginName }}'
    outputs:
      - Name: StdOut
        Selector: $.StandardOutputContent
        Type: String
      - Name: StdErr
        Selector: $.StandardErrorContent
        Type: String
      - Name: InvocationStatus
        Selector: $.Status
        Type: String

# Document-level outputs
outputs:
  - 'ExtractInstance.InstanceId'
  - 'RunAnsible.CommandId'
  - 'GetAnsibleOutput.StdOut'
  - 'GetAnsibleOutput.StdErr'
  - 'GetAnsibleOutput.InvocationStatus'
