---
schemaVersion: '0.3'
description: Run Ansible on a stack-managed EC2 instance and return stdout/stderr

parameters:
  StackName:
    type: String
  AnsibleS3Bucket:
    type: String
  AnsibleS3Key:
    type: String
  AnsibleUser:
    type: String
    default: ansible
  JiraDownloadUrl:
    type: String
  JiraDbPassword:
    type: String
  JiraTlsCertB64:
    type: String
  JiraTlsKeyB64:
    type: String

mainSteps:
  - name: DescribeStack
    action: aws:executeAwsApi
    inputs:
      Service: cloudformation
      Api: DescribeStacks
      StackName: '{{ StackName }}'
    outputs:
      - Name: Stack
        Selector: $.Stacks[0]
        Type: Map

  - name: ExtractInstance
    action: aws:executeScript
    inputs:
      Runtime: python3.11
      Handler: get_instance
      Script: |-
        def get_instance(event, _):
            for o in event.get('stack', {}).get('Outputs', []):
                if o.get('OutputKey') == 'InstanceId':
                    return {'InstanceId': str(o.get('OutputValue'))}
            raise ValueError('No InstanceId output found in the stack.')
      InputPayload:
        stack: '{{ DescribeStack.Stack }}'
    outputs:
      - Name: InstanceId
        Selector: $.Payload.InstanceId
        Type: String

  - name: BuildExtraVars
    action: aws:executeScript
    inputs:
      Runtime: python3.11
      Handler: build_vars
      Script: |-
        import json
        def build_vars(event, _):
            return {
              'ExtraVars': json.dumps({
                'jira_download_url': event['jira_download_url'],
                'jira_db_password': event['jira_db_password'],
                'jira_tls_cert_b64': event['jira_tls_cert_b64'],
                'jira_tls_key_b64': event['jira_tls_key_b64'],
                'ansible_user': event['ansible_user'],
              })
            }
      InputPayload:
        jira_download_url: '{{ JiraDownloadUrl }}'
        jira_db_password: '{{ JiraDbPassword }}'
        jira_tls_cert_b64: '{{ JiraTlsCertB64 }}'
        jira_tls_key_b64: '{{ JiraTlsKeyB64 }}'
        ansible_user: '{{ AnsibleUser }}'
    outputs:
      - Name: ExtraVars
        Selector: $.Payload.ExtraVars
        Type: String

  - name: InstallCollections
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: SendCommand
      DocumentName: AWS-RunShellScript
      InstanceIds:
        - '{{ ExtractInstance.InstanceId }}'
      Parameters:
        commands:
          - set -euo pipefail
          # 1) Ensure ansible is present (package mgrs or pip as a fallback)
          - |
            if ! command -v ansible-galaxy >/dev/null 2>&1; then
              if command -v dnf >/dev/null 2>&1; then
                dnf -y install ansible-core python3-pip
              elif command -v yum >/dev/null 2>&1; then
                if command -v amazon-linux-extras >/dev/null 2>&1; then amazon-linux-extras enable ansible2 || true; fi
                yum -y install ansible python3-pip || yum -y install ansible-core python3-pip
              elif command -v apt-get >/dev/null 2>&1; then
                apt-get update
                apt-get -y install ansible python3-pip
              else
                python3 -m pip install --upgrade pip
                python3 -m pip install 'ansible>=2.15,<2.18'
              fi
            fi
          # 2) Ensure boto3 for amazon.aws (only needed if you actually use it)
          - |
            python3 - <<'PY'
            import importlib, sys, subprocess
            try:
                importlib.import_module('boto3')
            except Exception:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--quiet', 'boto3', 'botocore'])
            PY
          # 3) Install the collections into the default path (~/.ansible/collections)
          - ansible-galaxy collection install amazon.aws community.postgresql community.general --force
        executionTimeout: ["1800"]

  - name: RunAnsible
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: SendCommand
      DocumentName: AWS-ApplyAnsiblePlaybooks
      InstanceIds:
        - '{{ ExtractInstance.InstanceId }}'
      Parameters:
        SourceType: ['S3']
        # Virtual-hostedâ€“style S3 URL is fine; path-style also works.
        SourceInfo: ['{"path":"https://{{ AnsibleS3Bucket }}.s3.amazonaws.com/{{ AnsibleS3Key }}"}']
        InstallDependencies: ['True']
        PlaybookFile: ['playbooks/site.yml']
        # Ansible accepts JSON for --extra-vars; see notes below.
        ExtraVariables: ['{{ BuildExtraVars.ExtraVars }}']
        Check: ['False']
        Verbose: ['-vv']
        TimeoutSeconds: ['3600']
    outputs:
      - Name: CommandId
        Selector: $.Command.CommandId
        Type: String

  # Wait for a terminal status so we can always capture logs (success or fail).
  - name: WaitForCommand
    action: aws:waitForAwsResourceProperty
    inputs:
      Service: ssm
      Api: ListCommandInvocations
      CommandId: '{{ RunAnsible.CommandId }}'
      InstanceId: '{{ ExtractInstance.InstanceId }}'
      Details: true
      PropertySelector: '$.CommandInvocations[0].Status'
      DesiredValues: ['Success', 'Failed', 'Cancelled', 'TimedOut']

  # Get the list of plugins used by this SendCommand (download, shell, etc.)
  - name: DiscoverPlugins
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: ListCommandInvocations
      CommandId: '{{ RunAnsible.CommandId }}'
      InstanceId: '{{ ExtractInstance.InstanceId }}'
      Details: true
    outputs:
      - Name: Plugins
        Selector: $.CommandInvocations[0].CommandPlugins
        Type: MapList

  # Pick the plugin that actually ran Ansible (aws:runShellScript).
  - name: PickAnsiblePlugin
    action: aws:executeScript
    inputs:
      Runtime: python3.11
      Handler: pick
      Script: |-
        def pick(event, _):
            # Prefer the last aws:runShellScript plugin (that's the Ansible run).
            plugins = event.get('plugins', [])
            candidates = [p for p in plugins if p.get('Name') == 'aws:runShellScript']
            if candidates:
                return {'PluginName': candidates[-1].get('Name')}
            # Fallback to the last plugin if not found
            if plugins:
                return {'PluginName': plugins[-1].get('Name')}
            raise ValueError('No plugins found for command.')
      InputPayload:
        plugins: '{{ DiscoverPlugins.Plugins }}'
    outputs:
      - Name: PluginName
        Selector: $.Payload.PluginName
        Type: String

  # Fetch stdout/stderr for the selected plugin.
  - name: GetAnsibleOutput
    action: aws:executeAwsApi
    inputs:
      Service: ssm
      Api: GetCommandInvocation
      CommandId: '{{ RunAnsible.CommandId }}'
      InstanceId: '{{ ExtractInstance.InstanceId }}'
      PluginName: '{{ PickAnsiblePlugin.PluginName }}'
    outputs:
      - Name: StdOut
        Selector: $.StandardOutputContent
        Type: String
      - Name: StdErr
        Selector: $.StandardErrorContent
        Type: String
      - Name: InvocationStatus
        Selector: $.Status
        Type: String

# Document-level outputs
outputs:
  - 'ExtractInstance.InstanceId'
  - 'RunAnsible.CommandId'
  - 'GetAnsibleOutput.StdOut'
  - 'GetAnsibleOutput.StdErr'
  - 'GetAnsibleOutput.InvocationStatus'
